<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#
    var fieldDetailsList = GetFieldDetailsList();
    var componentDetails = GetComponentDetails();
    var generatedHeader = CommonGeneratorUtils.GetGeneratedHeader();
    var commandDetailsList = GetCommandDetailsList();
    var eventDetailsList = GetEventDetailsList();
    var componentNamespace = qualifiedNamespace + "." + componentDetails.ComponentName;
    var profilingStart = $"Profiler.BeginSample(\"{componentDetails.ComponentName}\");";
    var profilingEnd = "Profiler.EndSample();";
#>
<#= generatedHeader #>

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Profiling;
using Unity.Mathematics;
using Unity.Entities;
using Unity.Collections;
using Improbable.Worker.CInterop;
using Improbable.Gdk.Core;
using Improbable.Gdk.Core.CodegenAdapters;
using Improbable.Gdk.Core.Commands;

namespace <#= qualifiedNamespace #>
{
    public partial class <#= componentDetails.ComponentName #>
    {
<# foreach (var command in commandDetailsList) {
        var requestType = command.CommandName + ".Request";
        var receivedRequestType = command.CommandName + ".ReceivedRequest";
        var responseType = command.CommandName + ".Response";
        var receivedResponseType = command.CommandName + ".ReceivedResponse";
#>
        public class <#= command.CommandName #>CommandManager : IComponentCommandManager<
            <#= requestType #>, <#= responseType #>, <#= receivedRequestType #>, <#= receivedResponseType #>>
        {
            private readonly Improbable.Worker.CInterop.CommandParameters shortCircuitingParameters = new CommandParameters
            {
                AllowShortCircuiting = true
            };

            private WorkerSystem workerSystem;
            private EntityManager entityManager;

            private List<(<#= requestType #> Request, long Id)> requestsToSend = new List<(<#= requestType #> Request, long Id)>();
            private List<<#= receivedRequestType #>> requestsReceived = new List<<#= receivedRequestType #>>();

            private List<<#= receivedResponseType #>> responsesReceived = new List<<#= receivedResponseType #>>();
            private List<<#= responseType #>> responsesToSend = new List<<#= responseType #>>();

            private Dictionary<long, <#= requestType #>> sentInternalRequestIdToRequest = new Dictionary<long, <#= requestType #>>();
            private Dictionary<long, Unity.Entities.Entity> sentInternalRequestIdToEntity = new Dictionary<long, Unity.Entities.Entity>();

            private Dictionary<long, long> sentWorkerRequestIdToInternalRequestId = new Dictionary<long, long>();

            public Type GetRequestType()
            {
                return typeof(<#= requestType #>);
            }

            public Type GetReceivedRequestType()
            {
                return typeof(<#= receivedRequestType #>);
            }

            public Type GetResponseType()
            {
                return typeof(<#= responseType #>);
            }

            public Type GetReceivedResponseType()
            {
                return typeof(<#= receivedResponseType #>);
            }

            public void SendAll()
            {
                var connection = workerSystem.Connection;

                foreach (var (request, id) in requestsToSend)
                {
                    var schemaCommandRequest = new global::Improbable.Worker.CInterop.SchemaCommandRequest(ComponentId, <#= command.CommandIndex #>);
                    <#= command.FqnRequestType #>.Serialization.Serialize(request.Payload, schemaCommandRequest.GetObject());

                    var requestId = connection.SendCommandRequest(request.TargetEntityId.Id,
                        new global::Improbable.Worker.CInterop.CommandRequest(schemaCommandRequest),
                        <#= command.CommandIndex #>,
                        request.TimeoutMillis,
                        request.AllowShortCircuiting ? shortCircuitingParameters : null);

                    sentWorkerRequestIdToInternalRequestId[requestId] = id;
                }

                foreach (var response in responsesToSend)
                {
                    if (response.FailureMessage != null)
                    {
                        // Send a command failure if the string is non-null.
                        connection.SendCommandFailure((uint) response.RequestId, response.FailureMessage);
                        continue;
                    }

                    var schemaCommandResponse = new global::Improbable.Worker.CInterop.SchemaCommandResponse(ComponentId, <#= command.CommandIndex #>);
                    <#= command.FqnResponseType #>.Serialization.Serialize(response.Payload.Value, schemaCommandResponse.GetObject());

                    connection.SendCommandResponse((uint) response.RequestId, new global::Improbable.Worker.CInterop.CommandResponse(schemaCommandResponse));
                }

                requestsToSend.Clear();
                requestsReceived.Clear();
                responsesReceived.Clear();
                responsesToSend.Clear();
            }

            public void Init(World world)
            {
                workerSystem = world.GetExistingManager<WorkerSystem>();

                if (workerSystem == null)
                {
                    throw new ArgumentException("World instance is not running a valid SpatialOS worker");
                }

                var dispatcher = world.GetExistingManager<SpatialOSReceiveSystem>().Dispatcher;

                dispatcher.OnCommandRequest(AddRequest);
                dispatcher.OnCommandResponse(AddResponse);
            }

            public long SendCommand(<#= requestType #> request, Unity.Entities.Entity entity)
            {
                var id = global::Improbable.Gdk.Core.CommandRequestIdGenerator.GetNext();
                requestsToSend.Add((request, id));
                sentInternalRequestIdToEntity.Add(id, entity);
                sentInternalRequestIdToRequest[id] = request;
                return id;
            }

            public void SendResponse(<#= responseType #> response)
            {
                // todo consider if empty strings should be treated as errors
                if (!response.Payload.HasValue && response.FailureMessage == null)
                {
                    throw new ArgumentException("Command responses must have either a non-null payload or a non-null error message");
                }

                responsesToSend.Add(response);
            }

            public List<(<#= requestType #> Request, long Id)> GetRequestsToSend()
            {
                return requestsToSend;
            }

            public List<<#= receivedRequestType #>> GetRequestsReceived()
            {
                return requestsReceived;
            }

            public List<<#= responseType #>> GetResponsesToSend()
            {
                return responsesToSend;
            }

            public List<<#= receivedResponseType #>> GetResponsesReceived()
            {
                return responsesReceived;
            }

            public bool TryGetResponseReceivedForRequestId(long requestId, out <#= receivedResponseType #> response)
            {
                foreach (var r in responsesReceived)
                {
                    if (r.RequestId == requestId)
                    {
                        response = r;
                        return true;
                    }
                }

                response = default(<#= receivedResponseType #>);
                return false;
            }

            private void AddRequest(CommandRequestOp op)
            {
                var componentId = op.Request.ComponentId;
                if (componentId != ComponentId)
                {
                    return;
                }

                var commandIndex = op.Request.SchemaData.Value.GetCommandIndex();
                if (commandIndex != <#= command.CommandIndex #>)
                {
                    return;
                }

                var deserializedRequest = <#= command.FqnRequestType #>.Serialization.Deserialize(op.Request.SchemaData.Value.GetObject());

                var request = new <#= receivedRequestType #>(
                    new EntityId(op.EntityId),
                    op.RequestId,
                    op.CallerWorkerId,
                    op.CallerAttributeSet,
                    deserializedRequest);

                requestsReceived.Add(request);
            }

            private void AddResponse(CommandResponseOp op)
            {
                var componentId = op.Response.ComponentId;
                if (componentId != ComponentId)
                {
                    return;
                }

                var commandIndex = op.CommandIndex;
                if (commandIndex != <#= command.CommandIndex #>)
                {
                    return;
                }

                <#= command.FqnResponseType #>? rawResponse = null;
                if (op.StatusCode == StatusCode.Success)
                {
                    rawResponse = <#= command.FqnResponseType #>.Serialization.Deserialize(op.Response.SchemaData.Value.GetObject());
                }

                var internalRequestId = sentWorkerRequestIdToInternalRequestId[op.RequestId];
                sentWorkerRequestIdToInternalRequestId.Remove(op.RequestId);

                var sendingEntity = sentInternalRequestIdToEntity[internalRequestId];
                sentInternalRequestIdToEntity.Remove(internalRequestId);

                var request = sentInternalRequestIdToRequest[internalRequestId];
                sentInternalRequestIdToRequest.Remove(internalRequestId);

                var response = new <#= receivedResponseType #>(
                    sendingEntity,
                    new EntityId(op.EntityId),
                    op.Message,
                    op.StatusCode,
                    rawResponse,
                    request.Payload,
                    request.Context,
                    internalRequestId);

                responsesReceived.Add(response);
            }
        }

<# } #>
    }
}
