<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#
    var fieldDetailsList = GetFieldDetailsList();
    var componentDetails = GetComponentDetails();
    var generatedHeader = CommonGeneratorUtils.GetGeneratedHeader();
    var commandDetailsList = GetCommandDetailsList();
    var eventDetailsList = GetEventDetailsList();
    var componentNamespace = qualifiedNamespace + "." + componentDetails.ComponentName;
    var profilingStart = $"Profiler.BeginSample(\"{componentDetails.ComponentName}\");";
    var profilingEnd = "Profiler.EndSample();";
#>
<#= generatedHeader #>

using System.Collections.Generic;
using Unity.Entities;
using Improbable.Gdk.Core;
using Improbable.Worker.CInterop;

namespace <#= qualifiedNamespace #>
{
    public partial class <#= componentDetails.ComponentName #>
    {
        public class UpdateReactiveComponentManager : IReactiveComponentManager
        {
            public void PopulateReactiveComponents(ComponentUpdateSystem updateSystem, EntityManager entityManager, WorkerSystem workerSystem, World world)
            {
                var updatesReceived = updateSystem.GetComponentUpdatesReceived<Update>();

                for (int i = 0; i < updatesReceived.Count; ++i)
                {
                    ref readonly var update = ref updatesReceived[i];
                    if (!workerSystem.TryGetEntity(update.EntityId, out var entity))
                    {
                        continue;
                    }

                    List<Update> updates;
                    if (entityManager.HasComponent<<#= componentNamespace #>.ReceivedUpdates>(entity))
                    {
                        updates = entityManager.GetComponentData<<#= componentNamespace #>.ReceivedUpdates>(entity).Updates;
                    }
                    else
                    {
                        updates = Update.Pool.Count > 0 ? Update.Pool.Pop() : new List<Update>();
                        var updatesComponent = new ReceivedUpdates
                        {
                            handle = ReferenceTypeProviders.UpdatesProvider.Allocate(world)
                        };
                        ReferenceTypeProviders.UpdatesProvider.Set(updatesComponent.handle, updates);
                        entityManager.AddComponentData(entity, updatesComponent);
                    }

                    updates.Add(update.Update);
                }
            }
        }

        public class AddComponentReactiveComponentManager : IReactiveComponentManager
        {
            public void PopulateReactiveComponents(ComponentUpdateSystem updateSystem, EntityManager entityManager, WorkerSystem workerSystem, World world)
            {
                var added = updateSystem.GetComponentsAdded(ComponentId);

                foreach (var entityId in added)
                {
                    if (!workerSystem.TryGetEntity(entityId, out var entity))
                    {
                        continue;
                    }

                    if (entityManager.HasComponent<ComponentRemoved<Component>>(entity))
                    {
                        entityManager.RemoveComponent<ComponentRemoved<Component>>(entity);
                    }

                    entityManager.AddComponent(entity, ComponentType.Create<ComponentAdded<Component>>());
                }
            }
        }

        public class RemoveComponentReactiveComponentManager : IReactiveComponentManager
        {
            public void PopulateReactiveComponents(ComponentUpdateSystem updateSystem, EntityManager entityManager, WorkerSystem workerSystem, World world)
            {
                var removed = updateSystem.GetComponentsRemoved(ComponentId);

                foreach (var entityId in removed)
                {
                    if (!workerSystem.TryGetEntity(entityId, out var entity))
                    {
                        continue;
                    }

                    if (entityManager.HasComponent<ComponentAdded<Component>>(entity))
                    {
                        entityManager.RemoveComponent<ComponentAdded<Component>>(entity);
                    }

                    entityManager.AddComponent(entity, ComponentType.Create<ComponentRemoved<Component>>());
                }
            }
        }

        public class AuthorityReactiveComponentManager : IReactiveComponentManager
        {
            public void PopulateReactiveComponents(ComponentUpdateSystem updateSystem, EntityManager entityManager, WorkerSystem workerSystem, World world)
            {
                var authorityChanges = updateSystem.GetAuthorityChangesReceived(ComponentId);

                for (int i = 0; i < authorityChanges.Count; ++i)
                {
                    ref readonly var auth = ref authorityChanges[i];
                    if (!workerSystem.TryGetEntity(auth.EntityId, out var entity))
                    {
                        continue;
                    }

                    List<Authority> changes;
                    if (entityManager.HasComponent<AuthorityChanges<Component>>(entity))
                    {
                        changes = entityManager.GetComponentData<AuthorityChanges<Component>>(entity).Changes;
                    }
                    else
                    {
                        changes = new List<Authority>();
                        var authComponent = new AuthorityChanges<Component>
                        {
                            Handle = AuthorityChangesProvider.Allocate(world)
                        };
                        AuthorityChangesProvider.Set(authComponent.Handle, changes);
                        entityManager.AddComponentData(entity, authComponent);
                    }

                    changes.Add(auth.Authority);
                }
            }
        }
<# foreach (var ev in eventDetailsList) {
        var eventType = ev.EventName + ".Event";
        var reactiveType = "ReceivedEvents." + ev.EventName;
#>

        public class <#= ev.EventName#>EventReactiveComponentManager : IReactiveComponentManager
        {
            public void PopulateReactiveComponents(ComponentUpdateSystem updateSystem, EntityManager entityManager, WorkerSystem workerSystem, World world)
            {
                var eventsReceived = updateSystem.GetEventsReceived<<#= eventType #>>();

                for (int i = 0; i < eventsReceived.Count; ++i)
                {
                    ref readonly var ev = ref eventsReceived[i];
                    if (!workerSystem.TryGetEntity(ev.EntityId, out var entity))
                    {
                        continue;
                    }

                    List<<#= ev.FqnPayloadType #>> events;
                    if (entityManager.HasComponent<<#= reactiveType #>>(entity))
                    {
                        events = entityManager.GetComponentData<<#= reactiveType #>>(entity).Events;
                    }
                    else
                    {
                        events = new List<<#= ev.FqnPayloadType #>>();
                        var eventsComponent = new <#= reactiveType #>
                        {
                            handle = ReferenceTypeProviders.<#= ev.EventName #>Provider.Allocate(world)
                        };
                        ReferenceTypeProviders.<#= ev.EventName #>Provider.Set(eventsComponent.handle, events);
                        entityManager.AddComponentData(entity, eventsComponent);
                    }

                    events.Add(ev.Event.Payload);
                }
            }
        }
<# } #>
    }
}
