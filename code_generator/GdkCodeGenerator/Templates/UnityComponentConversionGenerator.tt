<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#
    var fieldDetailsList = GetFieldDetailsList();
    var componentDetails = GetComponentDetails();
    var generatedHeader = CommonGeneratorUtils.GetGeneratedHeader();
    var commandDetailsList = GetCommandDetailsList();
    var eventDetailsList = GetEventDetailsList();
#>
<#= generatedHeader #>

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Unity.Mathematics;
using Unity.Entities;
using Improbable.Worker.Core;
using Improbable.Gdk.Core;
using Improbable.Gdk.Core.CodegenAdapters;

namespace <#= qualifiedNamespace #>
{
    public partial class <#= componentDetails.ComponentName #>
    {
        public class DispatcherHandler : ComponentDispatcherHandler
        {
            public override uint ComponentId => <#= componentDetails.ComponentId #>;

            private readonly EntityManager entityManager;
            private readonly global::Unity.Entities.World world;

            private const string LoggerName = "<#= componentDetails.ComponentName #>.DispatcherHandler";

            public DispatcherHandler(MutableView mutableView, global::Unity.Entities.World world) : base(mutableView, world)
            {
                entityManager = mutableView.EntityManager;
                this.world = world;
            }

            public override void Dispose() 
            {
<# foreach (var fieldDetails in fieldDetailsList) { #>
<# if (!fieldDetails.IsBlittable) { #>
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= fieldDetails.PascalCaseName #>Provider.CleanDataInWorld(world);
<# } #>
<# } #>
            }

            public override void OnAddComponent(AddComponentOp op)
            {
                if (!IsValidEntityId(op.EntityId, "AddComponentOp", out var entity))
                {
                    return;
                }
                var data =  global::<#= qualifiedNamespace #>.<#= componentDetails.TypeName #>.Serialization.Deserialize(op.Data.SchemaData.Value.GetFields(), world);
                data.DirtyBit = false;
                entityManager.AddComponentData(entity, data);
                entityManager.AddComponentData(entity, new NotAuthoritative<<#= componentDetails.TypeName #>>());

                if (entityManager.HasComponent<ComponentRemoved<<#= componentDetails.TypeName #>>>(entity))
                {
                    entityManager.RemoveComponent<ComponentRemoved<<#= componentDetails.TypeName #>>>(entity);
                }
                else if (!entityManager.HasComponent<ComponentAdded<<#= componentDetails.TypeName #>>>(entity))
                {
                    entityManager.AddComponentData(entity, new ComponentAdded<<#= componentDetails.TypeName #>>());
                }
                else 
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(ReceivedDuplicateComponentAdded)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                        .WithField("Component", "<#= componentDetails.TypeName #>")
                    );
                }
            }

            public override void OnRemoveComponent(RemoveComponentOp op)
            {
                if (!IsValidEntityId(op.EntityId, "RemoveComponentOp", out var entity))
                {
                    return;
                }
<# if (!componentDetails.IsBlittable) { #>

                var data = entityManager.GetComponentData<<#= componentDetails.TypeName #>>(entity);
<# foreach (var fieldDetails in fieldDetailsList) { #>
<# if (!fieldDetails.IsBlittable) { #>
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= fieldDetails.PascalCaseName #>Provider.Free(data.<#= fieldDetails.CamelCaseName #>Handle);
<# } #>
<# } #>
<# } #>

                entityManager.RemoveComponent<<#= componentDetails.TypeName #>>(entity);

                if (entityManager.HasComponent<ComponentAdded<<#= componentDetails.TypeName #>>>(entity))
                {
                    entityManager.RemoveComponent<ComponentAdded<<#= componentDetails.TypeName #>>>(entity);
                }
                else if (!entityManager.HasComponent<ComponentRemoved<<#= componentDetails.TypeName #>>>(entity))
                {
                    entityManager.AddComponentData(entity, new ComponentRemoved<<#= componentDetails.TypeName #>>());
                }
                else 
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(ReceivedDuplicateComponentRemoved)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                        .WithField("Component", "<#= componentDetails.TypeName #>")
                    );
                }
            }

            public override void OnComponentUpdate(ComponentUpdateOp op)
            {
                if (!IsValidEntityId(op.EntityId, "OnComponentUpdate", out var entity))
                {
                    return;
                }

                var data = entityManager.GetComponentData<<#= componentDetails.TypeName #>>(entity);

                var update = global::<#= qualifiedNamespace #>.<#= componentDetails.TypeName #>.Serialization.GetAndApplyUpdate(op.Update.SchemaData.Value.GetFields(), ref data);

                if (entityManager.HasComponent<<#= componentDetails.TypeName #>.ReceivedUpdates>(entity))
                {
                    var updates = entityManager.GetComponentData<<#= componentDetails.TypeName #>.ReceivedUpdates>(entity);
                    updates.Updates.Add(update);
                }
                else 
                {
                    var updates = new <#= componentDetails.TypeName #>.ReceivedUpdates
                    {
                        handle = ReferenceTypeProviders.UpdatesProvider.Allocate(world)
                    };
                    ReferenceTypeProviders.UpdatesProvider.Set(updates.handle, new List<<#= componentDetails.TypeName #>.Update>());
                    entityManager.AddComponentData(entity, updates);
                }

                // TODO: Events?

                data.DirtyBit = false;
                entityManager.SetComponentData(entity, data);
            }

            public override void OnAuthorityChange(AuthorityChangeOp op)
            {
                if (!IsValidEntityId(op.EntityId, "AuthorityChangeOp", out var entity))
                {
                    return;
                }

                ApplyAuthorityChange(entity, op.Authority, op.EntityId);
            }

            public override void OnCommandRequest(CommandRequestOp op)
            {
                if (!IsValidEntityId(op.EntityId, "CommandRequestOp", out var entity))
                {
                    return;
                }

                var commandIndex = op.Request.SchemaData.Value.GetCommandIndex();
                switch (commandIndex)
                {
<# foreach(var commandDetails in commandDetailsList) { #>
                    case <#= commandDetails.CommandIndex #>:
                        On<#= commandDetails.CommandName #>Request(op);
                        break;
<# } #>
                    default:
                        LogDispatcher.HandleLog(LogType.Error, new LogEvent(CommandIndexNotFound)
                            .WithField(LoggingUtils.LoggerName, LoggerName)
                            .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                            .WithField("CommandIndex", commandIndex)
                            .WithField("Component", "<#= componentDetails.TypeName #>")
                        );
                        break;
                }
            }

            public override void OnCommandResponse(CommandResponseOp op)
            {
                if (!IsValidEntityId(op.EntityId, "CommandResponseOp", out var entity))
                {
                    return;
                }

                var commandIndex = op.Response.SchemaData.Value.GetCommandIndex();
                switch (commandIndex)
                {
<# foreach(var commandDetails in commandDetailsList) { #>
                    case <#= commandDetails.CommandIndex #>:
                        On<#= commandDetails.CommandName #>Response(op);
                        break;
<# } #>
                    default:
                        LogDispatcher.HandleLog(LogType.Error, new LogEvent(CommandIndexNotFound)
                            .WithField(LoggingUtils.LoggerName, LoggerName)
                            .WithField(LoggingUtils.EntityId, op.EntityId.Id)
                            .WithField("CommandIndex", commandIndex)
                            .WithField("Component", "<#= componentDetails.TypeName #>")
                        );
                        break;
                }
            }

            private void ApplyAuthorityChange(Unity.Entities.Entity entity, Authority authority, global::Improbable.Worker.EntityId entityId)
            {
                switch (authority)
                {
                    case Authority.Authoritative:
                        if (!entityManager.HasComponent<NotAuthoritative<<#= componentDetails.TypeName #>>>(entity)) 
                        {
                            LogInvalidAuthorityTransition(Authority.Authoritative, Authority.NotAuthoritative, entityId);
                            return;
                        }

                        entityManager.RemoveComponent<NotAuthoritative<<#= componentDetails.TypeName #>>>(entity);
                        entityManager.AddComponentData(entity, new Authoritative<<#= componentDetails.TypeName #>>());
                        break;
                    case Authority.AuthorityLossImminent:
                        if (!entityManager.HasComponent<Authoritative<<#= componentDetails.TypeName #>>>(entity)) 
                        {
                            LogInvalidAuthorityTransition(Authority.AuthorityLossImminent, Authority.Authoritative, entityId);
                            return;
                        }

                        entityManager.AddComponentData(entity, new AuthorityLossImminent<<#= componentDetails.TypeName #>>());
                        break;
                    case Authority.NotAuthoritative:
                        if (!entityManager.HasComponent<Authoritative<<#= componentDetails.TypeName #>>>(entity))
                        {
                            LogInvalidAuthorityTransition(Authority.NotAuthoritative, Authority.Authoritative, entityId);
                            return;
                        }

                        if (entityManager.HasComponent<AuthorityLossImminent<<#= componentDetails.TypeName #>>>(entity))
                        {
                            entityManager.RemoveComponent<AuthorityLossImminent<<#= componentDetails.TypeName #>>>(entity);
                        }

                        entityManager.RemoveComponent<Authoritative<<#= componentDetails.TypeName #>>>(entity);
                        entityManager.AddComponentData(entity, new NotAuthoritative<<#= componentDetails.TypeName #>>());
                        break;
                }

                // TODO: Add to authorities changed list
            }

            private bool IsValidEntityId(global::Improbable.Worker.EntityId entityId, string opType, out Unity.Entities.Entity entity)
            {
                if (!MutableView.TryGetEntity(entityId, out entity))
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(EntityNotFound)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, entityId.Id)
                        .WithField("Op", opType)
                        .WithField("Component", "<#= componentDetails.TypeName #>")
                    );
                    return false;
                }

                return true;
            }

            private void LogInvalidAuthorityTransition(Authority newAuthority, Authority expectedOldAuthority, global::Improbable.Worker.EntityId entityId)
            {
                LogDispatcher.HandleLog(LogType.Error, new LogEvent(InvalidAuthorityChange)
                    .WithField(LoggingUtils.LoggerName, LoggerName)
                    .WithField(LoggingUtils.EntityId, entityId.Id)
                    .WithField("New Authority", newAuthority)
                    .WithField("Expected Old Authority", expectedOldAuthority)
                    .WithField("Component", "<#= componentDetails.TypeName #>")
                );
            }

<# foreach (var command in commandDetailsList) { #>
            private void On<#= command.CommandName #>Request(CommandRequestOp op)
            {
                // TODO: Implement commands
            }

            private void On<#= command.CommandName #>Response(CommandResponseOp op)
            {
                // TODO: Implement commands
            }
<# } #>
        }

        public class ComponentReplicator : ComponentReplicationHandler 
        {
            public override uint ComponentId => <#= componentDetails.ComponentId #>;

            public override ComponentType[] ReplicationComponentTypes => new ComponentType[] {
                typeof(<#= componentDetails.TypeName #>), 
                typeof(Authoritative<<#= componentDetails.TypeName #>>), 
                typeof(SpatialEntityId)
            };

            public override ComponentType[] CommandTypes => new ComponentType[] {
<# foreach (var command in commandDetailsList) { #>

<# } #>
            };

            public ComponentReplicator(EntityManager entityManager) : base(entityManager)
            {
            }

            public override void ExecuteReplication(ComponentGroup replicationGroup, Connection connection)
            {
                var componentData = replicationGroup.GetComponentDataArray<<#= componentDetails.TypeName #>>();
                var entityIdData = replicationGroup.GetComponentDataArray<SpatialEntityId>();

                for (var i = 0; i < componentData.Length; i++) 
                {
                    var data = componentData[i];
                    if (data.DirtyBit)
                    {
                        var update = new global::Improbable.Worker.Core.SchemaComponentUpdate(<#= componentDetails.ComponentId #>);
                        <#= componentDetails.TypeName #>.Serialization.Serialize(data, update.GetFields());
                        connection.SendComponentUpdate(entityIdData[i].EntityId, new global::Improbable.Worker.Core.ComponentUpdate(update));

                        // TODO: Generate event serialization into update

                        data.DirtyBit = false;
                        componentData[i] = data;
                    }
                }
            }

            public override void SendCommands(List<ComponentGroup> commandComponentGroups, Connection connection)
            {
                // TODO: Generate command serialization
            }

        }

        public class ComponentCleanup : ComponentCleanupHandler 
        {
            public override ComponentType[] CleanUpComponentTypes => cleanUpComponentTypes;
            private static readonly ComponentType[] cleanUpComponentTypes = {
                typeof(ComponentAdded<<#= componentDetails.TypeName #>>),
                typeof(ComponentRemoved<<#= componentDetails.TypeName #>>)
                // TODO: More to come potentially
            };

            public override ComponentType ComponentUpdateType => ComponentType.Create<<#= componentDetails.TypeName #>.ReceivedUpdates>();

            public override void CleanupUpdates(ComponentGroup updateGroup, ref EntityCommandBuffer buffer)
            {
                var entities = updateGroup.GetEntityArray();
                var data = updateGroup.GetComponentDataArray<<#= componentDetails.TypeName #>.ReceivedUpdates>();
                for (var i = 0; i < entities.Length; i++)
                {
                    buffer.RemoveComponent<<#= componentDetails.TypeName #>.ReceivedUpdates>(entities[i]);
                    ReferenceTypeProviders.UpdatesProvider.Free(data[i].handle);
                }
            }
        }
    }

}
